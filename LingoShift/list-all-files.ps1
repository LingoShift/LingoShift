# Funzione per ottenere i contenuti dei file e annotarli
function Get-FileContentsWithAnnotations {
    param (
        [string]$FolderPath,  # Percorso della cartella di partenza
        [string]$OutputFile   # Percorso del file di output
    )

    # Verifica se la cartella esiste
    if (-Not (Test-Path -Path $FolderPath -PathType Container)) {
        Write-Host "La cartella specificata non esiste: $FolderPath"
        return
    }

    # Trova tutte le sottocartelle nella cartella root
    $subfolders = Get-ChildItem -Path $FolderPath -Directory

    # Mostra l'elenco delle sottocartelle all'utente
    Write-Host "Sottocartelle trovate:"
    for ($i = 0; $i -lt $subfolders.Count; $i++) {
        Write-Host "$($i + 1). $($subfolders[$i].Name)"
    }

    # Chiedi all'utente di selezionare le sottocartelle da processare
    $selection = Read-Host "Inserisci i numeri delle sottocartelle da processare, separati da virgola (es. 1,3,5)"

    # Converti la selezione in un array di numeri
    $selectedIndexes = $selection -split "," | ForEach-Object { $_.Trim() } | Where-Object { $_ -match '^\d+$' } | ForEach-Object { [int]$_ - 1 }

    # Filtra le sottocartelle selezionate
    $selectedSubfolders = $selectedIndexes | ForEach-Object { $subfolders[$_] }

    # Trova tutti i file .cs e .xaml nelle sottocartelle selezionate
    $files = @()
    foreach ($subfolder in $selectedSubfolders) {
        $files += Get-ChildItem -Path $subfolder.FullName -Recurse -Include *.cs, *.axaml
    }

    # Ordina i file per il loro percorso relativo
    $files = $files | Sort-Object { $_.FullName.Replace($FolderPath, "") }

    # Inizializza il file di output
    Clear-Content -Path $OutputFile -ErrorAction SilentlyContinue
    New-Item -Path $OutputFile -ItemType File -Force | Out-Null

    # Elabora ogni file trovato
    foreach ($file in $files) {
        try {
            # Leggi il contenuto del file
            $content = Get-Content -Path $file.FullName -Raw

            # Salta i file che contengono <auto-generated/> o <auto-generated />
            if ($content -match "generated" -or $content -match "<auto-generated />") {
                Write-Host "Saltato file auto-generato: $($file.FullName)"
                continue
            }

            # Calcola il percorso relativo del file
            $relativePath = $file.FullName.Replace($FolderPath, "").TrimStart("\\")

            # Aggiungi l'intestazione con il percorso relativo del file
            "File: $relativePath" | Out-File -FilePath $OutputFile -Append -Force
            ("-" * 50) | Out-File -FilePath $OutputFile -Append -Force

            # Aggiungi il contenuto del file al file di output
            $content | Out-File -FilePath $OutputFile -Append -Force
            "`n`n" | Out-File -FilePath $OutputFile -Append -Force  # Aggiunge una nuova riga per separare i file
        } catch {
            Write-Host "Errore durante la lettura del file: $($file.FullName)"
        }
    }

    Write-Host "Il contenuto dei file Ã¨ stato salvato in $OutputFile"
}

# Esempio di utilizzo
$folderPath = "C:\Users\CRS\source\repos\LingoShift"  # Modifica con il percorso della tua cartella
$outputFile = "C:\Users\CRS\source\repos\LingoShift\LingoShift\projectfiles.txt"  # Modifica con il percorso del file di output

# Chiama la funzione con i parametri specificati
Get-FileContentsWithAnnotations -FolderPath $folderPath -OutputFile $outputFile